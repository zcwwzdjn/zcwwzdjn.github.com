---
layout: post
title: "Codeforces Round #170 (Div. 1)"
description: ""
category: OI
tags: [Codeforces]
---

开小号做的这场比赛，结果惨跪。如果是用大号做的话不知道会跌成什么样子。

## A
`n`个人`m`种语言，每个人会一些语言，每个人学习一门新语言花费为`1`，问最小花费使得人们可以互相通信。

这不就是二分图求个连通块就完事了么，并查集水一水就行了。

不过大多数人第一次交都没考虑到**所有人都一门语言不会**的情况吧。

## B
构造`n`个点，使得存在`m`个点构成凸包，且不存在超过`m`个点构成凸包。

构造题什么的**完全不会**啊！

不过我还是YY了一个算法，就是说用`y = x`和`y = -x`两条直线把平面分成`4`块。
然后在上面那一块内构造一个`m`个点的凸包，这个凸包要满足最上面的边是水平的，其余边构成一个下凸壳。
然后把其余的`n - m`个点用类似的办法在下面构造，这样使得上下的点最多构成`4`个点的凸包。

但是我忘了**不能三点共线**啊！

我考试的时候写的代码会有若干个点在`y = x`上，于是轻松没过pretest。然后比赛就结束了。

构造凸壳的办法就很多了，因为坐标范围很大，所以随便搞搞就可以了。

## C
一个网格从`(0, 0)`到`(n, m)`，两个人轮流操作，一次操作是沿着网格线切一刀，不能操作者输。
问是否先手必胜，若是的话输出任意一个可行的第一步切法。注意有可能这个图上已经切了若干刀了。

显然每一行每一列都是独立的啊，这样找找规律就知道SG是什么了。

但是，我理解的是**切过的地方不能再切**，结果题意是**每一次切必须切到没切过的**！

然后就没有然后了，过了pretest然后喜闻乐见FST。

其实这题代码有点恶心，多用STL简化代码吧。

## D
给了一个GCJ的比赛规则，告诉你`n`道题，每道题有Small和Large两个部分分，然后分别有一个做出来需要的时间。
每道题的Small都是能过的，但是Large有一个概率会错。设考试时间为`t`，首先要求最大期望得分。
但这还不够，比赛中要计算罚时，计算方法是**最后一道正确的题目的提交时间**。还要求最大期望得分下的最小期望罚时。

考试的时候完全没欲望想这题，精度居然放到了坑爹的`10 ^ (-9)`，即使写出来也可能挂在精度上。

其实是**完全没时间想这道题**啊！

其实这种题还是蛮喜闻乐见的，首先做题顺序不影响最大期望得分，我们只用考虑对罚时的影响。

设两个题目，第一道题Small的时间是`s1`，Large的时间是`l1`，Large错的概率是`f1`。同理定义第二道题的。
那么，由于Small一定是会先做的，所以不考虑这部分时间。先做第一题再做第二题的期望罚时是：

`f1(1 - f2) * (l1 + l2) + (1 - f1)f2 * l1 + (1 - f1)(1 - f2) * (l1 + l2)`

先做第二题再做第一题的期望罚时是：

`f1(1 - f2) * l2 + (1 - f1)f2 * (l1 + l2) + (1 - f1)(1 - f2) * (l1 + l2)`

然后做差可以得到第一题在第二题之前出需要满足的条件是：

`f1(1 - f2) * l1 < (1 - f1)f2 * l2`

于是就可一先排一下序，然后直接动态规划就可以了。
设`f[i][j]`表示前`i`道题，在前`j`的时间的最大期望得分，`g[i][j]`表示对应的期望最小罚时，转移的时候分一道题不做，做Small，做Small和Large三种情况考虑。
注意做Small时，这道题做的顺序应该插入到**所有Large之前**，所以新的罚时应该是以`g[i][j]`为基础。
但是要做Large时，新的罚时应该是以`j`为基础。这个地方比较蛋疼。

精度问题的话，把那个概率乘`10 ^ 6`后当成整数做就行了。

## E
给平面上`n`个点，每个点只能向纵坐标比它低的点连有向边，问是否能构成一棵二叉有根树，若能输出最小树边长度和。

考试的时候根本**没看这道题**有木有！

其实是傻逼题。
除根以外每个点恰好一个入度，每个点最多两个出度，于是建一个网络流图，左边一列表示入度，右边一列表示出度，然后按照题意连边，跑一个最小费用最大流就完了。

和上场TC的1000分题**如出一辙**啊！TC那题我做出了，这题却没出。

## 吐槽
现在都流行小号么？？？

现在都流行开黑么？？？

完了要落伍了啊。。。

{% include JB/setup %}
